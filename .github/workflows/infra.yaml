name: Provision Infra (EKS + ECR)
on:
  workflow_dispatch:   # manual trigger only
jobs:
  provision:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      # Configure AWS credentials
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      # Get current IAM identity
      - name: Get Current IAM Principal ARN
        id: get-caller
        run: |
          CALLER_ARN=$(aws sts get-caller-identity --query Arn --output text)
          echo "caller-arn=$CALLER_ARN" >> $GITHUB_OUTPUT
          echo "Current IAM Principal: $CALLER_ARN"
      
      # Deploy CloudFormation Stack
      - name: Deploy CloudFormation Stack
        run: |
          aws cloudformation deploy \
            --stack-name product-assistant-cluster \
            --template-file infra/eks-with-ecr.yaml \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --region ${{ secrets.AWS_REGION }}
      
      # Wait for cluster to be ready
      - name: Wait for EKS Cluster
        run: |
          echo "Waiting for cluster to be active..."
          aws eks wait cluster-active \
            --name product-assistant-cluster-latest \
            --region ${{ secrets.AWS_REGION }}
      
      # Create Access Entry
      - name: Create EKS Access Entry
        run: |
          PRINCIPAL_ARN="${{ steps.get-caller.outputs.caller-arn }}"
          CLUSTER_NAME="product-assistant-cluster-latest"
          
          echo "Creating access entry for: $PRINCIPAL_ARN"
          
          # Check if access entry already exists
          if aws eks describe-access-entry \
            --cluster-name $CLUSTER_NAME \
            --principal-arn $PRINCIPAL_ARN \
            --region ${{ secrets.AWS_REGION }} 2>/dev/null; then
            echo "Access entry already exists"
          else
            echo "Creating new access entry"
            aws eks create-access-entry \
              --cluster-name $CLUSTER_NAME \
              --principal-arn $PRINCIPAL_ARN \
              --region ${{ secrets.AWS_REGION }}
          fi
      
      # Associate Admin Policy
      - name: Associate Access Policy
        run: |
          PRINCIPAL_ARN="${{ steps.get-caller.outputs.caller-arn }}"
          CLUSTER_NAME="product-assistant-cluster-latest"
          POLICY_ARN="arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy"
          
          echo "Associating admin policy..."
          
          # Check if policy is already associated
          if aws eks list-associated-access-policies \
            --cluster-name $CLUSTER_NAME \
            --principal-arn $PRINCIPAL_ARN \
            --region ${{ secrets.AWS_REGION }} \
            --query "associatedAccessPolicies[?policyArn=='$POLICY_ARN']" \
            --output text | grep -q .; then
            echo "Policy already associated"
          else
            echo "Associating new policy"
            aws eks associate-access-policy \
              --cluster-name $CLUSTER_NAME \
              --principal-arn $PRINCIPAL_ARN \
              --policy-arn $POLICY_ARN \
              --access-scope type=cluster \
              --region ${{ secrets.AWS_REGION }}
          fi
      
      # Configure kubectl
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --name product-assistant-cluster-latest \
            --region ${{ secrets.AWS_REGION }}
      
      # Create or Update aws-auth ConfigMap
      - name: Create aws-auth ConfigMap
        run: |
          PRINCIPAL_ARN="${{ steps.get-caller.outputs.caller-arn }}"
          NODE_ROLE_ARN=$(aws cloudformation describe-stacks \
            --stack-name product-assistant-cluster \
            --region ${{ secrets.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`NodeGroupRoleArn`].OutputValue' \
            --output text)
          
          USERNAME=$(echo $PRINCIPAL_ARN | rev | cut -d'/' -f1 | rev)
          
          echo "Creating aws-auth ConfigMap..."
          
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: aws-auth
            namespace: kube-system
          data:
            mapRoles: |
              - rolearn: ${NODE_ROLE_ARN}
                username: system:node:{{EC2PrivateDNSName}}
                groups:
                  - system:bootstrappers
                  - system:nodes
            mapUsers: |
              - userarn: arn:aws:iam::859037107780:user/prod-assistant
                username: prod-assistant
                groups:
                  - system:masters
              - userarn: ${PRINCIPAL_ARN}
                username: ${USERNAME}
                groups:
                  - system:masters
          EOF
          
          echo "✅ aws-auth ConfigMap created successfully"
      
      # Verify cluster access
      - name: Verify Cluster Access
        run: |
          echo "Testing cluster access..."
          kubectl get nodes
          kubectl get namespaces
          echo "✅ Successfully connected to EKS cluster!"
      
      - name: Describe CloudFormation Stack Events
        if: failure()
        run: |
          aws cloudformation describe-stack-events \
            --stack-name product-assistant-cluster \
            --region ${{ secrets.AWS_REGION }} \
            --query 'StackEvents[*].[ResourceType,LogicalResourceId,ResourceStatus,ResourceStatusReason]' \
            --output table
